import asyncio
import socket
socket.setdefaulttimeout(60)
import threading
import json
import hashlib
import binascii
import logging
from logging.handlers import RotatingFileHandler
import time
import sqlite3
import os
import signal
import sys
import psutil
import requests
from aiohttp import web
from socketserver import ThreadingMixIn, TCPServer, StreamRequestHandler
from threading import Lock
import aiohttp

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø—É–ª–∞
POOL_HOST = os.getenv("POOL_HOST", "165.22.46.160")
POOL_PORT = int(os.getenv("POOL_PORT", 3333))

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø—Ä–æ–∫—Å–∏ –¥–ª—è ASIC
ASIC_PROXY_HOST = os.getenv("ASIC_PROXY_HOST", "0.0.0.0")
ASIC_PROXY_PORT = int(os.getenv("ASIC_PROXY_PORT", 3333))

# –ü—É—Ç—å –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
DB_PATH = os.getenv("DB_PATH", "asic_proxy.db")

# –í–µ—Ä—Å–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
VERSION = "1.0.0"

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Telegram
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "7207281851:AAEzDaJmpvA6KB9xgTo7dnEbnW4LUtnH4FQ")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "480223056")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–≥–µ—Ä–∞
logger = logging.getLogger("ASICProxy")
logger.setLevel(logging.INFO)
handler = RotatingFileHandler("asic_proxy.log", maxBytes=10*1024*1024, backupCount=5)
formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è fix_hex_string
last_hex_warning_time = 0
hex_warning_shown = False

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è graceful shutdown
def handle_shutdown(signum, frame):
    logger.info("–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–µ—Ä–≤–µ—Ä...")
    if 'server' in globals():
        server.shutdown()
    sys.exit(0)

signal.signal(signal.SIGTERM, handle_shutdown)
signal.signal(signal.SIGINT, handle_shutdown)

async def ensure_port_available(port: int):
    """–û—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–æ—Ä—Ç, –∑–∞–≤–µ—Ä—à–∞—è –ø—Ä–æ—Ü–µ—Å—Å—ã, –∫–æ—Ç–æ—Ä—ã–µ –µ–≥–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç."""
    logger.info(f"[PORT] –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä—Ç–∞ {port}...")
    processed_pids = set()
    port_in_use_initial = any(p.laddr.port == port for p in psutil.net_connections(kind='inet'))
    if not port_in_use_initial:
        logger.info(f"[PORT] –ü–æ—Ä—Ç {port} —É–∂–µ —Å–≤–æ–±–æ–¥–µ–Ω.")
        return
    for conn in psutil.net_connections(kind='inet'):
        if conn.laddr.port == port and conn.pid not in processed_pids:
            try:
                proc = psutil.Process(conn.pid)
                logger.info(f"[PORT IN USE] –£–±–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å PID={conn.pid}, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–π –ø–æ—Ä—Ç :{port}")
                proc.terminate()
                try:
                    proc.wait(timeout=10)
                except psutil.TimeoutExpired:
                    logger.warning(f"[PORT] –ü—Ä–æ—Ü–µ—Å—Å PID={conn.pid} –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É–±–∏–≤–∞–µ–º...")
                    proc.kill()
                processed_pids.add(conn.pid)
                await asyncio.sleep(2)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞: {e}")
    timeout = 60
    start_time = time.time()
    while True:
        if time.time() - start_time > timeout:
            logger.error(f"[PORT] –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç {port} –∑–∞ {timeout} —Å–µ–∫—É–Ω–¥")
            raise RuntimeError(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç {port}")
        port_in_use = any(p.laddr.port == port for p in psutil.net_connections(kind='inet'))
        if not port_in_use:
            logger.info(f"[PORT] –ü–æ—Ä—Ç {port} –æ—Å–≤–æ–±–æ–¥–∏–ª—Å—è.")
            break
        await asyncio.sleep(1)

class TelegramHandler(logging.Handler):
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –ª–æ–≥–æ–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram."""
    def __init__(self, token, chat_id, loop=None):
        super().__init__()
        self.token = token
        self.chat_id = chat_id
        self.url = f"https://api.telegram.org/bot{token}/sendMessage"
        self.enabled = True
        self.shutdown_flag = False
        self.loop = loop or asyncio.get_event_loop()

    async def send_message(self, message):
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram."""
        async with aiohttp.ClientSession() as session:
            payload = {
                "chat_id": self.chat_id,
                "text": message,
                "parse_mode": "HTML"
            }
            try:
                async with session.post(self.url, data=payload, timeout=10) as resp:
                    await resp.text()
            except Exception as e:
                logger.error(f"[TelegramHandler] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤ Telegram: {e}")

    def emit(self, record):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –ª–æ–≥–æ–≤ –≤ Telegram."""
        if self.shutdown_flag or not self.enabled:
            return
        try:
            log_entry = self.format(record)
            keywords = ["submit", "notify", "asic", "pool", "share", "error"]
            if any(keyword in log_entry.lower() for keyword in keywords):
                message = f"üö® <b>{record.levelname}</b>\n<code>{log_entry}</code>"
                asyncio.run_coroutine_threadsafe(self.send_message(message), self.loop)
        except Exception as e:
            logger.error(f"[TelegramHandler] –û—à–∏–±–∫–∞ –≤ emit: {e}")

    def disable(self):
        self.shutdown_flag = True
        self.enabled = False

    def enable(self):
        self.enabled = True
        self.shutdown_flag = False

class ThreadedTCPServer(ThreadingMixIn, TCPServer):
    allow_reuse_address = True

class ASICHandler(StreamRequestHandler):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π –æ—Ç ASIC-—É—Å—Ç—Ä–æ–π—Å—Ç–≤."""
    def handle(self):
        logger.info(f"[ASIC] –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç {self.client_address[0]}")
        self.server.asic_socket = self.request
        while True:
            try:
                data = self.request.recv(4096).decode('utf-8')
                if data:
                    logger.info(f"[ASIC DATA] –ü–æ–ª—É—á–µ–Ω–æ –æ—Ç ASIC: {data}")
                    try:
                        msg = json.loads(data)
                        if msg.get("method") == "mining.configure":
                            response = {
                                "id": msg["id"],
                                "result": {"version-rolling": True},
                                "error": None
                            }
                            self.request.sendall((json.dumps(response) + '\n').encode('utf-8'))
                            logger.info(f"[ASIC] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω –æ—Ç–≤–µ—Ç –Ω–∞ mining.configure: {response}")
                        elif msg.get("method") == "mining.subscribe":
                            while not (hasattr(self.server, 'proxy') and self.server.proxy.extranonce1 is not None and self.server.proxy.extranonce2_size):
                                time.sleep(1)
                            response = {
                                "id": msg["id"],
                                "result": [["mining.notify", "ae6812eb4cd7735a"]],
                                "extranonce1": self.server.proxy.extranonce1,
                                "extranonce2_size": self.server.proxy.extranonce2_size
                            }
                            self.request.sendall((json.dumps(response) + '\n').encode('utf-8'))
                            logger.info(f"[ASIC] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω –æ—Ç–≤–µ—Ç –Ω–∞ mining.subscribe: {response}")
                            auth_msg = {
                                "id": msg["id"] + 1,
                                "method": "mining.authorize",
                                "params": ["worker", "x"]
                            }
                            self.server.proxy._send_to_pool(auth_msg)
                            self.request.sendall((json.dumps(auth_msg) + '\n').encode('utf-8'))
                            logger.info(f"[ASIC] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω mining.authorize: {auth_msg}")
                        elif msg.get("method") == "mining.authorize":
                            if hasattr(self.server, 'proxy'):
                                self.server.proxy._send_to_pool(msg)
                                response = {"id": msg["id"], "result": True, "error": None}
                                self.request.sendall((json.dumps(response) + '\n').encode('utf-8'))
                                logger.info(f"[ASIC] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω –æ—Ç–≤–µ—Ç –Ω–∞ mining.authorize: {response}")
                                self.server.proxy.authorized = True
                        elif msg.get("method") == "mining.submit" and hasattr(self.server, 'proxy'):
                            self.server.proxy._send_to_pool(msg)
                            logger.info(f"[ASIC] –®–∞—Ä–∞ –ø–æ–ª—É—á–µ–Ω–∞ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥—å –¥–ª—è –ø—É–ª–∞: {msg}")
                        elif hasattr(self.server, 'proxy'):
                            self.server.proxy._send_to_pool(msg)
                    except json.JSONDecodeError:
                        logger.error(f"[ASIC DATA] –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON –æ—Ç ASIC: {data}")
                else:
                    logger.warning("[ASIC] –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å ASIC —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ")
                    break
            except Exception as e:
                logger.error(f"[ASIC] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ—Ç ASIC: {e}")
                break

class PoolConnector(Thread):
    """–°–æ–µ–¥–∏–Ω–∏—Ç–µ–ª—å —Å –º–∞–π–Ω–∏–Ω–≥-–ø—É–ª–æ–º —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –æ—á–µ—Ä–µ–¥–µ–π –¥–ª—è –ø—É–ª–∞ –∏ ASIC."""
    def __init__(self, server):
        super().__init__(daemon=True)
        self.server = server
        self.asic_socket = None
        self.pool_socket = None
        self.extranonce1 = None
        self.extranonce2_size = 0
        self.job_id = None
        self.difficulty = None
        self.authorized = False
        self.jobs = {}
        self.accepted_shares = 0
        self.rejected_shares = 0
        self.db_lock = Lock()
        self.conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        self.cur = self.conn.cursor()
        self._init_db()
        self.pool_queue = asyncio.Queue()
        self.asic_queue = asyncio.Queue()
        self.running = True

    def _init_db(self):
        with self.db_lock:
            self.cur.execute("""
                CREATE TABLE IF NOT EXISTS submits (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    extranonce2 TEXT,
                    timestamp INTEGER
                )
            """)
            self.conn.commit()

    def run(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(self._run_async())
        loop.close()

    async def _run_async(self):
        while self.running:
            try:
                logger.info(f"[POOL] –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ø—É–ª—É {POOL_HOST}:{POOL_PORT}...")
                with socket.create_connection((POOL_HOST, POOL_PORT)) as s:
                    self.pool_socket = s
                    logger.info(f"[POOL] –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ {POOL_HOST}:{POOL_PORT} —É—Å–ø–µ—à–Ω–æ")
                    self._subscribe()
                    await asyncio.gather(
                        self._read_pool_messages(),
                        self._process_pool_queue(),
                        self._process_asic_queue()
                    )
            except Exception as e:
                logger.error(f"[POOL] –û—à–∏–±–∫–∞ –≤ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏ —Å –ø—É–ª–æ–º: {e}")
                self.pool_socket = None
                await asyncio.sleep(5)

    async def _read_pool_messages(self):
        while self.running and self.pool_socket:
            try:
                self.pool_socket.settimeout(30.0)
                buffer = ""
                while True:
                    chunk = self.pool_socket.recv(4096).decode('utf-8')
                    if not chunk:
                        break
                    buffer += chunk
                    if buffer.count('{') == buffer.count('}') and buffer.endswith('\n'):
                        break
                if buffer:
                    for message in self._split_messages(buffer):
                        try:
                            self._handle_pool_message(json.loads(message))
                        except Exception as e:
                            logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø—É–ª–∞: {e}\n{message}")
                else:
                    logger.warning("[POOL] –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ø—É–ª–æ–º —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ")
                    break
            except socket.timeout:
                logger.warning("[RECV] –¢–∞–π–º–∞—É—Ç –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ—Ç –ø—É–ª–∞")
                continue
            except Exception as e:
                logger.error(f"[RECV] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {e}")
                break
        self.pool_socket = None

    async def _process_pool_queue(self):
        while self.running:
            try:
                msg = await self.pool_queue.get()
                if not self.pool_socket or self.pool_socket.fileno() == -1:
                    logger.warning("[POOL] –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ø—É–ª–æ–º –ø–æ—Ç–µ—Ä—è–Ω–æ, –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è...")
                    self.pool_queue.put_nowait(msg)
                    break
                if msg.get("method") not in ["mining.subscribe", "mining.authorize"] and not self.authorized:
                    logger.warning("[POOL] –ü—Ä–æ–ø—É—â–µ–Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫–∞, –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
                    self.pool_queue.put_nowait(msg)
                    await asyncio.sleep(1)
                    continue
                try:
                    message = json.dumps(msg) + '\n'
                    self.pool_socket.sendall(message.encode('utf-8'))
                    logger.debug(f"[POOL SEND] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –ø—É–ª: {msg}")
                    await asyncio.sleep(0.1)
                except Exception as e:
                    logger.error(f"[POOL SEND] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}, –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è...")
                    self.pool_queue.put_nowait(msg)
                    self.pool_socket = None
                    break
                finally:
                    self.pool_queue.task_done()
            except Exception as e:
                logger.error(f"[POOL QUEUE] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏: {e}")
                await asyncio.sleep(1)

    async def _process_asic_queue(self):
        while self.running:
            try:
                msg = await self.asic_queue.get()
                if not self.asic_socket or self.asic_socket.fileno() == -1:
                    logger.warning("[ASIC] ASIC-—Å–æ–∫–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø—ã—Ç–∞–µ–º—Å—è –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è...")
                    self.asic_queue.put_nowait(msg)
                    self._reconnect_asic()
                    await asyncio.sleep(1)
                    continue
                try:
                    message = json.dumps(msg) + '\n'
                    self.asic_socket.sendall(message.encode('utf-8'))
                    logger.info(f"[ASIC SEND] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ ASIC: {msg}")
                    await asyncio.sleep(0.05)
                except Exception as e:
                    logger.error(f"[ASIC SEND] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")
                    self.asic_queue.put_nowait(msg)
                    self._reconnect_asic()
                finally:
                    self.asic_queue.task_done()
            except Exception as e:
                logger.error(f"[ASIC QUEUE] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏: {e}")
                await asyncio.sleep(1)

    def _split_messages(self, data):
        return data.strip().split('\n')

    def _send_to_pool(self, msg):
        asyncio.run_coroutine_threadsafe(self.pool_queue.put(msg), asyncio.get_event_loop())
        logger.debug(f"[POOL QUEUE] –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å: {msg}")

    def _send_to_asic(self, msg):
        asyncio.run_coroutine_threadsafe(self.asic_queue.put(msg), asyncio.get_event_loop())
        logger.info(f"[ASIC QUEUE] –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å: {msg}")

    def _reconnect_asic(self):
        logger.warning("[RECONNECT] –ü–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ ASIC...")
        try:
            if self.asic_socket and self.asic_socket.fileno() != -1:
                self.asic_socket.close()
            self.asic_socket = None
            while not self.asic_socket and self.running:
                if hasattr(self.server, 'asic_socket') and self.server.asic_socket.fileno() != -1:
                    self.asic_socket = self.server.asic_socket
                    logger.info("[RECONNECT] –£—Å–ø–µ—à–Ω–æ–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ ASIC")
                    break
                time.sleep(1)
        except Exception as e:
            logger.error(f"[RECONNECT] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ ASIC: {e}")

    def _subscribe(self):
        self._send_to_pool({"id": 1, "method": "mining.subscribe", "params": []})
        self._send_to_pool({"id": 2, "method": "mining.authorize", "params": ["worker", "x"]})

    def _handle_pool_message(self, msg):
        logger.debug(f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø—É–ª–∞: {msg}")
        if msg.get("method") == "mining.set_difficulty":
            self.difficulty = msg['params'][0]
            self._send_to_asic({
                "id": None,
                "method": "mining.set_difficulty",
                "params": [self.difficulty]
            })
        elif msg.get("method") == "mining.notify" and self.authorized:
            params = msg.get("params", [])
            if isinstance(params, list) and len(params) >= 8:
                self._handle_notify(params[:8])
            else:
                logger.error(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç notify: {params}")
        elif msg.get("result") and isinstance(msg['result'], list):
            self.extranonce1 = msg['result'][1]
            self.extranonce2_size = msg['result'][2]
            logger.info(f"[EXTRANONCE1] –ü–æ–ª—É—á–µ–Ω: {self.extranonce1}, —Ä–∞–∑–º–µ—Ä: {self.extranonce2_size}")
        elif msg.get("id") == 2 and msg.get("result") is True:
            self.authorized = True
            logger.info("[POOL] –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≤ –ø—É–ª–µ —É—Å–ø–µ—à–Ω–∞")
        elif "id" in msg and "method" not in msg and not isinstance(msg.get("result"), list):
            if msg.get("result") is True:
                self.accepted_shares += 1
                logger.info("[SHARE] –ü—Ä–∏–Ω—è—Ç–∞")
            else:
                self.rejected_shares += 1
                logger.info(f"[SHARE] –û—Ç–∫–ª–æ–Ω–µ–Ω–∞: {msg.get('error')}")

    def _handle_notify(self, params):
        try:
            job_id, coinb1, coinb2, merkle_branch, version, nbits, ntime, clean_jobs = params
            logger.debug(f"[RAW NOTIFY] job_id={job_id}, coinb1={coinb1}, coinb2={coinb2}, merkle_branch={merkle_branch}")
            coinb1 = fix_hex_string(coinb1)
            coinb2 = fix_hex_string(coinb2)
            extranonce2 = self._select_best_extranonce2(job_id)
            extranonce1 = fix_hex_string(self.extranonce1) if self.extranonce1 else "00"
            merkle_root = calculate_merkle_root(coinb1, coinb2, extranonce1, extranonce2, merkle_branch)
            logger.info(f"[FILTERED] job_id={job_id} ‚Üí best extranonce2: {extranonce2}")
            logger.info(f"[MERKLE ROOT] job_id={job_id} ‚Üí {merkle_root}")
            logger.info(f"[SEND] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ ASIC: job_id={job_id}")
            self._send_to_asic({
                "id": None,
                "method": "mining.notify",
                "params": [job_id, coinb1, coinb2, merkle_branch, version, nbits, ntime, clean_jobs]
            })
        except Exception as e:
            logger.error(f"[HANDLE NOTIFY] –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ notify: {e}")

    def _select_best_extranonce2(self, job_id):
        candidates = [f"{i:08x}" for i in range(256)]
        weights = {}
        for ex2 in candidates:
            total = sum(hashlib.sha256(bytes.fromhex(ex2)).digest())
            weights[ex2] = total % (2**32)
        sorted_weights = sorted(weights.items(), key=lambda item: item[1])
        top = sorted_weights[-5:]
        for val, score in top:
            logger.info(f"  - {val} -> –≤–µ—Å: {score}")
        best = top[-1][0] if top else "00000000"
        return best

    def stop(self):
        self.running = False
        if self.pool_socket:
            self.pool_socket.close()
        if self.asic_socket:
            self.asic_socket.close()
        self.conn.close()

def fix_hex_string(s):
    global last_hex_warning_time, hex_warning_shown
    current_time = time.time()
    if len(s) % 2 != 0:
        if not hex_warning_shown or (current_time - last_hex_warning_time >= 100):
            logger.warning(f"[HEX FIX] –°—Ç—Ä–æ–∫–∞ –Ω–µ—á—ë—Ç–Ω–æ–π –¥–ª–∏–Ω—ã, –¥–æ–±–∞–≤–ª—è–µ–º 0: {s}")
            last_hex_warning_time = current_time
            hex_warning_shown = True
        s = '0' + s
    return s

def calculate_merkle_root(coinb1, coinb2, extranonce1, extranonce2, branches):
    coinb1 = fix_hex_string(coinb1)
    coinb2 = fix_hex_string(coinb2)
    extranonce1 = fix_hex_string(extranonce1)
    extranonce2 = fix_hex_string(extranonce2)
    branches = [fix_hex_string(b) for b in branches]
    coinbase = coinb1 + extranonce1 + extranonce2 + coinb2
    logger.debug(f"[COINBASE RAW] {coinbase}")
    coinbase_bin = binascii.unhexlify(coinbase)
    coinbase_hash = hashlib.sha256(hashlib.sha256(coinbase_bin).digest()).digest()
    merkle_root = coinbase_hash
    for branch in branches:
        merkle_root = hashlib.sha256(hashlib.sha256(merkle_root + binascii.unhexlify(branch)).digest()).digest()
    return merkle_root.hex()

async def main_async():
    global server, proxy, telegram_handler
    logger.info("[STARTUP] –ü—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ...")
    try:
        logger.info(f"[PORT] –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä—Ç–∞ {ASIC_PROXY_PORT}...")
        await ensure_port_available(ASIC_PROXY_PORT)
        logger.info(f"[PORT] –ü–æ—Ä—Ç {ASIC_PROXY_PORT} –¥–æ—Å—Ç—É–ø–µ–Ω.")
        logger.info(f"[SERVER] –ó–∞–ø—É—Å–∫ TCP-—Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ {ASIC_PROXY_HOST}:{ASIC_PROXY_PORT}...")
        server = ThreadedTCPServer((ASIC_PROXY_HOST, ASIC_PROXY_PORT), ASICHandler)
        proxy = PoolConnector(server)
        server.proxy = proxy
        proxy.start()
        threading.Thread(target=server.serve_forever, daemon=True).start()
        logger.info(f"[SERVER] –ü—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ {ASIC_PROXY_HOST}:{ASIC_PROXY_PORT}")

        async def handle_status(request):
            return web.json_response({
                "version": VERSION,
                "accepted_shares": proxy.accepted_shares,
                "rejected_shares": proxy.rejected_shares,
                "connected": proxy.pool_socket is not None,
                "pool_queue_size": proxy.pool_queue.qsize(),
                "asic_queue_size": proxy.asic_queue.qsize()
            })

        async def handle_shutdown(request):
            telegram_handler.disable()
            logger.info("[TELEGRAM] –û—Ç–∫–ª—é—á–µ–Ω–æ —á–µ—Ä–µ–∑ /shutdown")
            proxy.stop()
            sys.exit(0)

        app = web.Application()
        app.add_routes([
            web.get('/status', handle_status),
            web.get('/shutdown', handle_shutdown)
        ])
        runner = web.AppRunner(app)
        await runner.setup()
        site = web.TCPSite(runner, '0.0.0.0', 8080)
        await site.start()
        logger.info("[HTTP] –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É 8080")

        current_loop = asyncio.get_running_loop()
        telegram_handler = TelegramHandler(TELEGRAM_TOKEN, TELEGRAM_CHAT_ID, loop=current_loop)
        telegram_handler.setLevel(logging.DEBUG)
        telegram_handler.setFormatter(formatter)
        logger.addHandler(telegram_handler)

        while True:
            await asyncio.sleep(3600)
    except Exception as e:
        logger.error(f"[MAIN] –û—à–∏–±–∫–∞ –≤ main_async: {e}")
        raise
    finally:
        logger.info("–ó–∞–∫—Ä—ã–≤–∞–µ–º —Ä–µ—Å—É—Ä—Å—ã...")
        proxy.stop()
        if 'proxy' in globals() and proxy.conn:
            proxy.conn.close()
        if 'server' in globals():
            server.shutdown()

if __name__ == "__main__":
    try:
        asyncio.run(main_async())
    except KeyboardInterrupt:
        logger.warning("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ Ctrl+C")
        try:
            telegram_handler.disable()
            logger.info("[TELEGRAM] –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ.")
            proxy.stop()
            server.shutdown()
            logger.info("[SERVER] –°–µ—Ä–≤–µ—Ä –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")
        except Exception as e:
            logger.error(f"[ERROR] –ü—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ —Å–µ—Ä–≤–µ—Ä–∞: {e}")
        sys.exit(0)